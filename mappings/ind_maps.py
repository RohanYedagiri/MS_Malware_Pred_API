import ast
import pandas as pd
import numpy as np
import lightgbm as lgb
from sklearn.externals import joblib
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import SGDClassifier
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import AdaBoostClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import ExtraTreesClassifier
import category_encoders


def parse_short_json(request):

    Census_SystemVolumeTotalCapacity = request.form['Census_SystemVolumeTotalCapacity']
    CountryIdentifier_new = int(request.form['CountryIdentifier_new'])
    Census_InternalPrimaryDiagonalDisplaySizeInInches = request.form[
        'Census_InternalPrimaryDiagonalDisplaySizeInInches']
    AppVersion2_new = int(request.form['AppVersion2_new'])
    Wdft_RegionIdentifier = int(request.form['Wdft_RegionIdentifier'])
    Census_OSInstallTypeName = request.form['Census_OSInstallTypeName']
    Census_OSVersion3_new = int(request.form['Census_OSVersion3_new'])
    Census_OSUILocaleIdentifier_new = int(request.form['Census_OSUILocaleIdentifier_new'])
    AvSigVersion1_new = int(request.form['AvSigVersion1_new'])
    Census_TotalPhysicalRAM = request.form['Census_TotalPhysicalRAM']
    AppVersion3_new = int(request.form['AppVersion3_new'])
    AVProductStatesIdentifier_new = int(request.form['AVProductStatesIdentifier_new'])

    a = np.array([Census_SystemVolumeTotalCapacity,
                  CountryIdentifier_new,
                  Census_InternalPrimaryDiagonalDisplaySizeInInches,
                  AppVersion2_new,
                  Wdft_RegionIdentifier,
                  Census_OSInstallTypeName,
                  Census_OSVersion3_new,
                  Census_OSUILocaleIdentifier_new,
                  AvSigVersion1_new,
                  Census_TotalPhysicalRAM,
                  AppVersion3_new,
                  AVProductStatesIdentifier_new]).reshape((1, -1))

    cols = ['Census_SystemVolumeTotalCapacity',
            'CountryIdentifier_new',
            'Census_InternalPrimaryDiagonalDisplaySizeInInches',
            'AppVersion2_new',
            'Wdft_RegionIdentifier',
            'Census_OSInstallTypeName',
            'Census_OSVersion3_new',
            'Census_OSUILocaleIdentifier_new',
            'AvSigVersion1_new',
            'Census_TotalPhysicalRAM',
            'AppVersion3_new',
            'AVProductStatesIdentifier_new']

    v = pd.DataFrame(a, columns=cols)

    # Encoding
    num_encode = ['Census_SystemVolumeTotalCapacity',
                  'Census_TotalPhysicalRAM',
                  'Census_InternalPrimaryDiagonalDisplaySizeInInches']

    freqs = ['CountryIdentifier_new',
             'AppVersion2_new',
             'Wdft_RegionIdentifier',
             'Census_OSInstallTypeName',
             'Census_OSVersion3_new',
             'Census_OSUILocaleIdentifier_new',
             'AvSigVersion1_new',
             'AppVersion3_new',
             'AVProductStatesIdentifier_new']

    scaler = joblib.load('./data/models/short/short_Minmaxscaler.pkl')
    target_enc = joblib.load('./data/models/short/short_Target_enc.pkl')

    # A = v[no_encode].values
    B = scaler.transform(v[num_encode])
    C = target_enc.transform(v[freqs]).values

    encoded_feats = np.concatenate((B, C), axis=1)

    # step3: predict the output

    # load SGDclassifier
    model = joblib.load('./data/models/short/short_sg.pkl')
    sgd = model.predict_proba(encoded_feats)[0][1]

    # load Naive Bayes
    model = joblib.load('./data/models/short/short_nb.pkl')
    nb = model.predict_proba(encoded_feats)[0][1]

    # load logistic regression
    model = joblib.load('./data/models/short/short_lg.pkl')
    lg = model.predict_proba(encoded_feats)[0][1]

    # load Linear Discriminant Analysis
    model = joblib.load('./data/models/short/short_lda.pkl')
    lda = model.predict_proba(encoded_feats)[0][1]

    # load AdaBoostClassifier
    model = joblib.load('./data/models/short/short_ada.pkl')
    ada = model.predict_proba(encoded_feats)[0][1]

    # load GradientBoostingClassifier
    model = joblib.load('./data/models/short/short_gbm.pkl')
    gbm = model.predict_proba(encoded_feats)[0][1]

    # RandomForestClassifier
    model = joblib.load('./data/models/short/short_rf.pkl')
    rf = model.predict_proba(encoded_feats)[0][1]

    # ExtraTreesClassifier
    model = joblib.load('./data/models/short/short_et.pkl')
    et = model.predict_proba(encoded_feats)[0][1]

    # LGBMClassifier
    model = joblib.load('./data/models/short/short_lgbm.pkl')
    lgbm = model.predict_proba(encoded_feats)[0][1]

    ensemble_feats = np.array([sgd, nb, lg, lda, ada, gbm, rf, et, lgbm]).reshape(1, -1)

    model = joblib.load('./data/models/short/short_NN.pkl')
    detections = model.predict_proba(ensemble_feats)[0][1]

    short_feats_list = [Census_SystemVolumeTotalCapacity,
                        CountryIdentifier_new,
                        Census_InternalPrimaryDiagonalDisplaySizeInInches,
                        AppVersion2_new,
                        Wdft_RegionIdentifier,
                        Census_OSInstallTypeName,
                        Census_OSVersion3_new,
                        Census_OSUILocaleIdentifier_new,
                        AvSigVersion1_new,
                        Census_TotalPhysicalRAM,
                        AppVersion3_new,
                        AVProductStatesIdentifier_new]
    # short_feats = np.array(short_feats_list).reshape(1, -1)
    # short_model = lgb.Booster(model_file='./data/models/Short_LGB_Model.txt')
    # detections = short_model.predict(short_feats)
    # detections = round(detections[0], 2)

    if detections > 0.5:
        interpretation = 'Device is vulnerable'
    else:
        interpretation = 'Device is safe'

    # step4: return result json
    result1 = {
        'Status': 'Success',
        'Threshold_limit': 0.5,
        'Has_Detections': detections,
        'Interpretation': interpretation
    }
    return short_feats_list, result1
