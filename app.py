from flask import Flask, jsonify, request, render_template, url_for
from flask_material import Material
from flask_restful import Resource, Api
from pickle import load
import pandas as pd
import numpy as np
import sklearn
import lightgbm
import lightgbm as lgb
# import xlrd
import openpyxl

app = Flask(__name__)
Material(app)
api = Api(app)


class Predict(Resource):
    def post(self):

        # step1: get the data
        feats = request.get_json()
        AVProductStatesIdentifier = feats["AVProductStatesIdentifier"]
        AVProductsInstalled = feats["AVProductsInstalled"]
        CountryIdentifier = feats["CountryIdentifier"]
        CityIdentifier = feats["CityIdentifier"]
        OrganizationIdentifier = feats["OrganizationIdentifier"]
        GeoNameIdentifier = feats["GeoNameIdentifier"]
        LocaleEnglishNameIdentifier = feats["LocaleEnglishNameIdentifier"]
        OsBuild = feats["OsBuild"]
        OsSuite = feats["OsSuite"]
        OsPlatformSubRelease = feats["OsPlatformSubRelease"]
        SkuEdition = feats["SkuEdition"]
        IeVerIdentifier = feats["IeVerIdentifier"]
        SmartScreen = feats["SmartScreen"]
        Census_MDC2FormFactor = feats["Census_MDC2FormFactor"]
        Census_OEMNameIdentifier = feats["Census_OEMNameIdentifier"]
        Census_OEMModelIdentifier = feats["Census_OEMModelIdentifier"]
        Census_ProcessorCoreCount = feats["Census_ProcessorCoreCount"]
        Census_ProcessorModelIdentifier = feats["Census_ProcessorModelIdentifier"]
        Census_PrimaryDiskTotalCapacity = feats["Census_PrimaryDiskTotalCapacity"]
        Census_PrimaryDiskTypeName = feats["Census_PrimaryDiskTypeName"]
        Census_SystemVolumeTotalCapacity = feats["Census_SystemVolumeTotalCapacity"]
        Census_TotalPhysicalRAM = feats["Census_TotalPhysicalRAM"]
        Census_ChassisTypeName = feats["Census_ChassisTypeName"]
        Census_InternalPrimaryDiagonalDisplaySizeInInches = feats["Census_InternalPrimaryDiagonalDisplaySizeInInches"]
        Census_InternalPrimaryDisplayResolutionVertical = feats["Census_InternalPrimaryDisplayResolutionVertical"]
        Census_PowerPlatformRoleName = feats["Census_PowerPlatformRoleName"]
        Census_InternalBatteryNumberOfCharges = feats["Census_InternalBatteryNumberOfCharges"]
        Census_OSEdition = feats["Census_OSEdition"]
        Census_OSInstallTypeName = feats["Census_OSInstallTypeName"]
        Census_OSUILocaleIdentifier = feats["Census_OSUILocaleIdentifier"]
        Census_OSWUAutoUpdateOptionsName = feats["Census_OSWUAutoUpdateOptionsName"]
        Census_ActivationChannel = feats["Census_ActivationChannel"]
        Census_FirmwareManufacturerIdentifier = feats["Census_FirmwareManufacturerIdentifier"]
        Census_FirmwareVersionIdentifier = feats["Census_FirmwareVersionIdentifier"]
        Census_IsSecureBootEnabled = feats["Census_IsSecureBootEnabled"]
        Wdft_IsGamer = feats["Wdft_IsGamer"]
        Wdft_RegionIdentifier = feats["Wdft_RegionIdentifier"]
        engine_ver_1 = feats["engine_ver_1"]
        app_ver_1 = feats["app_ver_1"]
        app_ver_2 = feats["app_ver_2"]
        app_ver_3 = feats["app_ver_3"]
        avsig_ver_1 = feats["avsig_ver_1"]
        avsig_ver_2 = feats["avsig_ver_2"]
        OsBuildLab_ver_1 = feats["OsBuildLab_ver_1"]
        OsBuildLab_ver_3 = feats["OsBuildLab_ver_3"]
        OsBuildLab_ver_4 = feats["OsBuildLab_ver_4"]
        OsBuildLab_ver_5 = feats["OsBuildLab_ver_5"]
        Census_OS_ver_3 = feats["Census_OS_ver_3"]

        # step2: load the model
        # load model with pickle to predict
        bst = lgb.Booster(model_file='New_LGB_Model.txt')
        # can predict with any iteration when loaded in pickle way
        # y_pred = pkl_bst.predict(X_test, num_iteration=2803)
        # gbm = load(open('iris_model.sav', 'rb'))

        # step3: predict the output
        a = [AVProductStatesIdentifier,
             AVProductsInstalled,
             CountryIdentifier,
             CityIdentifier,
             OrganizationIdentifier,
             GeoNameIdentifier,
             LocaleEnglishNameIdentifier,
             OsBuild,
             OsSuite,
             OsPlatformSubRelease,
             SkuEdition,
             IeVerIdentifier,
             SmartScreen,
             Census_MDC2FormFactor,
             Census_OEMNameIdentifier,
             Census_OEMModelIdentifier,
             Census_ProcessorCoreCount,
             Census_ProcessorModelIdentifier,
             Census_PrimaryDiskTotalCapacity,
             Census_PrimaryDiskTypeName,
             Census_SystemVolumeTotalCapacity,
             Census_TotalPhysicalRAM,
             Census_ChassisTypeName,
             Census_InternalPrimaryDiagonalDisplaySizeInInches,
             Census_InternalPrimaryDisplayResolutionVertical,
             Census_PowerPlatformRoleName,
             Census_InternalBatteryNumberOfCharges,
             Census_OSEdition,
             Census_OSInstallTypeName,
             Census_OSUILocaleIdentifier,
             Census_OSWUAutoUpdateOptionsName,
             Census_ActivationChannel,
             Census_FirmwareManufacturerIdentifier,
             Census_FirmwareVersionIdentifier,
             Census_IsSecureBootEnabled,
             Wdft_IsGamer,
             Wdft_RegionIdentifier,
             engine_ver_1,
             app_ver_1,
             app_ver_2,
             app_ver_3,
             avsig_ver_1,
             avsig_ver_2,
             OsBuildLab_ver_1,
             OsBuildLab_ver_3,
             OsBuildLab_ver_4,
             OsBuildLab_ver_5,
             Census_OS_ver_3]
        a = np.array(a).reshape(1, -1)
        detections = bst.predict(a)
        # species = gbm.predict(a)
        detections = round(detections[0], 2)
        if detections > 0.5:
            interpretation = 'Device is vulnerable'
        else:
            interpretation = 'Device is safe'

        # step4: return result json
        result = {
            'Status': 'Success',
            'Threshold_limit': 0.5,
            'Has_Detections': detections,
            'Interpretation': interpretation
        }

        return jsonify(result)


api.add_resource(Predict, '/predict')


@app.route('/')
def index():
    return render_template('index.html')


# global d
d = pd.read_excel('encodings_draft.xlsx', sheet_name=None)


def lookup(dic, key, label, val):
    try:
        v = dic[key]
        l = v.loc[v['Unnamed: 0'] == label][val]
        trans = l.get_values()[0]
    except:
        trans = np.average(dic[key][val])
    return trans


@app.route('/result', methods=['POST'])
def result():
    if request.method == "POST":
        AVProductStatesIdentifier = request.form['AVProductStatesIdentifier']
        AVProductStatesIdentifier = lookup(d, 'AVProductStatesIdentifier', int(AVProductStatesIdentifier), 'smoothing')

        AVProductsInstalled = request.form['AVProductsInstalled']

        CountryIdentifier = request.form['CountryIdentifier']
        CountryIdentifier = lookup(d, 'CountryIdentifier', int(CountryIdentifier), 'smoothing')

        CityIdentifier = request.form['CityIdentifier']
        CityIdentifier = lookup(d, 'CityIdentifier', int(CityIdentifier), 'smoothing')

        SmartScreen = request.form['SmartScreen']
        SmartScreen = lookup(d, 'SmartScreen', SmartScreen, 'smoothing')

        Census_OEMModelIdentifier = request.form['Census_OEMModelIdentifier']
        Census_OEMModelIdentifier = lookup(d, 'Census_OEMModelIdentifier', int(Census_OEMModelIdentifier), 'smoothing')

        Census_ProcessorModelIdentifier = request.form['Census_ProcessorModelIdentifier']
        Census_ProcessorModelIdentifier = lookup(d, 'Census_ProcessorModelIdentifier',
                                                 int(Census_ProcessorModelIdentifier), 'smoothing')

        Census_SystemVolumeTotalCapacity = request.form['Census_SystemVolumeTotalCapacity']

        Census_OSInstallTypeName = request.form['Census_OSInstallTypeName']
        Census_OSInstallTypeName = lookup(d, 'Census_OSInstallTypeName', Census_OSInstallTypeName, 'smoothing')

        Census_FirmwareVersionIdentifier = request.form['Census_FirmwareVersionIdentifier']
        Census_FirmwareVersionIdentifier = lookup(d, 'Census_FirmwareVersionIdentifier',
                                                  int(Census_FirmwareVersionIdentifier), 'smoothing')

        avsig_ver_1 = request.form['avsig_ver_1']
        avsig_ver_1 = lookup(d, 'avsig_ver_1', int(avsig_ver_1), 'smoothing')

        avsig_ver_2 = request.form['avsig_ver_2']
        avsig_ver_2 = lookup(d, 'avsig_ver_2', int(avsig_ver_2), 'smoothing')

        Census_OS_ver_3 = request.form['Census_OS_ver_3']
        Census_OS_ver_3 = lookup(d, 'Census_OS_ver_3', int(Census_OS_ver_3), 'smoothing')

    # step2: load the model
    # load model with pickle to predict
    short_model = lgb.Booster(model_file='Short_LGB_Model.txt')

    short_feats = [AVProductStatesIdentifier,
                   AVProductsInstalled,
                   CountryIdentifier,
                   CityIdentifier,
                   SmartScreen,
                   Census_OEMModelIdentifier,
                   Census_ProcessorModelIdentifier,
                   Census_SystemVolumeTotalCapacity,
                   Census_OSInstallTypeName,
                   Census_FirmwareVersionIdentifier,
                   avsig_ver_1,
                   avsig_ver_2,
                   Census_OS_ver_3]
    short_feats = np.array(short_feats).reshape(1, -1)

    detections = short_model.predict(short_feats)
    detections = round(detections[0], 2)

    if detections > 0.5:
        interpretation = 'Device is vulnerable'
    else:
        interpretation = 'Device is safe'

    # step4: return result json
    result1 = {
        'Status': 'Success',
        'Threshold_limit': 0.5,
        'Has_Detections': detections,
        'Interpretation': interpretation
    }

    return render_template('index.html',
                           AVProductStatesIdentifier=AVProductStatesIdentifier,
                           AVProductsInstalled=AVProductsInstalled,
                           CountryIdentifier=CountryIdentifier,
                           CityIdentifier=CityIdentifier,
                           SmartScreen=SmartScreen,
                           Census_OEMModelIdentifier=Census_OEMModelIdentifier,
                           Census_ProcessorModelIdentifier=Census_ProcessorModelIdentifier,
                           Census_SystemVolumeTotalCapacity=Census_SystemVolumeTotalCapacity,
                           Census_OSInstallTypeName=Census_OSInstallTypeName,
                           Census_FirmwareVersionIdentifier=Census_FirmwareVersionIdentifier,
                           avsig_ver_1=avsig_ver_1,
                           avsig_ver_2=avsig_ver_2,
                           Census_OS_ver_3=Census_OS_ver_3,
                           result1=result1
                           )


if __name__ == '__main__':
    app.run(debug=True)
